import camelcase from 'camelcase'
import defaults from 'defaults'
import pluralize from 'pluralize'
import {
  GraphQLNonNull,
  GraphQLList,
  GraphQLID,
  GraphQLString,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLScalarType
} from 'graphql'
import {
  fromGlobalId
} from 'graphql-relay'
import _ from 'lodash'

import { StringHelper } from './utils/index'
import ModelRef from './ModelRef'
import Connection from './Connection'
import _type from './type'

export const getTableName = (model) => {
  return model.name
}

export const funcWrapper = (obj, args) => {
  if (typeof obj === 'function') {
    return obj(...args)
  }
  return obj
}

export const connectionNameForAssociation = (model, associationName) => {
  return StringHelper.toInitialUpperCase(camelcase(`${getTableName(model)}_to_${associationName}`))
}

export const getModelGrapqhQLConfig = (model) => {
  const config = defaults(model.graphql, {
    modelType: (modelType) => modelType,
    crud: {}
  })
  const defaultCrudEnable = _.isBoolean(config.crud.enable) ? config.crud.enable : true
  const defaultCrud = defaultCrudEnable ? (func) => func : false
  for (let crudType of ['add', 'read', 'update', 'delete']) {
    config.crud[crudType] = defaults(config.crud[crudType], {
      one: defaultCrud,
      all: defaultCrud
    })
    if (crudType !== 'read') {
      delete config.crud[crudType].all
    }
  }
  return config
}

export const getQueryName = (model, type, countType) => {
  if (type === 'read') {
    if (countType === 'all') {
      return camelcase(pluralize.plural(getTableName(model)))
    } else if (countType === 'one') {
      return camelcase(getTableName(model))
    }
  } else if (['add', 'update', 'delete'].indexOf(type) !== -1) {
    if (countType === 'all') {
      return camelcase(`${type}_${pluralize.plural(getTableName(model))}`)
    } else if (countType === 'one') {
      return camelcase(`${type}_${getTableName(model)}`)
    }
  }
  console.warn('Unknown query type: ', type)
  return camelcase(`${type}_${countType}_${getTableName(model)}`)
}

export const getQueryDescription = (model, type, countType) => {
  const tableName = getTableName(model)
  if (countType === 'all') {
    return `${type} ${countType} ${pluralize.plural(tableName)}.`
  } else if (countType === 'one') {
    return `${type} ${countType} ${tableName}.`
  } else {
    return `${type} ${countType} ${tableName}.`
  }
}

export const createNonNullList = (modelType) => {
  return new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(modelType)))
}

export const createNonNullListResolver = (resolver) => {
  return async (...args) => {
    const results = await resolver(...args)
    if (results === null) {
      return []
    } else if (Array.isArray(results)) {
      return results
    } else {
      return [results]
    }
  }
}

export const removePrimaryKeyOrAutoIncrement = (model, fields) => {
  for (let field in fields) {
    const attribute = model.rawAttributes[field]
    if (attribute.references) continue
    if (attribute._autoGenerated || attribute.autoIncrement) {
      delete fields[field]
    }
  }
}

export const globalIdInputNotNullField = (modelName) => {
  return {
    name: 'id',
    description: `The ID for ${modelName}`,
    type: new GraphQLNonNull(GraphQLID)
  }
}

export const globalIdInputField = (modelName) => {
  return {
    name: 'id',
    description: `The ID for ${modelName}`,
    type: GraphQLID
  }
}

export const pruneReferenceNotNull = (model, fields) => {
  for (let field in fields) {
    const attribute = model.rawAttributes[field]
    if (attribute.references) {
      const modelName = attribute.references.model.tableName
      fields[field] = globalIdInputField(modelName)
    }
  }
}

export const convertFieldsToGlobalId = (model, fields, isUpdateFields = false) => {
  _.forOwn(model.associations, (value, key) => {
    if (['BelongsTo'].indexOf(value.associationType) !== -1) {
      let globalIdType = _type.GraphQLScalarTypes.globalIdInputType(value.target.name)
      const required = _.get(value, 'options.required', false)
      if (required === true && isUpdateFields === false) globalIdType = new GraphQLNonNull(globalIdType)

      fields[value.foreignKey] = {
        description: `ID for ${key}`,
        type: globalIdType
      }
    }
  })
}

export const convertFieldsFromGlobalId = (fields, data) => {
  for (let field in fields) {
    const type = fields[field].type.toJSON()
    if (data[field] === undefined) continue
    if (type === 'ID' || type === 'ID!') {
      data[field] = fromGlobalId(data[field]).id
    }
  }
}

export const connectionName = (model) => {
  return `${model.name}Connection`
}

export const mappingTypes = (type, modelTypes, out) => {
  switch (type) {
    case String:
      return GraphQLString
    case Number:
      return GraphQLFloat
    case Boolean:
      return GraphQLBoolean
    case Date:
      return GraphQLScalarType.Dat
    case JSON:
      return GraphQLScalarType.Json
  }

  if (type instanceof ModelRef) {
    if (out) return modelTypes[type.name]
    return _type.GraphQLScalarTypes.globalIdInputType(type.name)
  }

  if (type instanceof Connection.ConnectionType) {
    return modelTypes[`${type.nodeType.name}Connection`].connectionType
  }
  // if (type instanceof GraphQLObjectType) return GraphQLID
  return type
}

export const outputFieldMap = (field, modelTypes) => {
  const { description } = field
  let type = mappingTypes(field.type || field, modelTypes, 1)
  // console.log('type', {...type})
  // return type
  return {
    type,
    description,
  }
}

export const fieldMap = (field) => {
  const { description } = field
  let type = mappingTypes(field.type || field)
  if (field.type) {
    type = field.allowNull === false ? new GraphQLNonNull(type) : type
  } else {
    type = new GraphQLNonNull(type)
  }
  return {
    type,
    description
  }
}

export const lcFirst = (name) => {
  if (name) {
    name = camelcase(name)
  }
  return name
}
